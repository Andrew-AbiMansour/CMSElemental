LogP:
=====
-  I: Select a scientific model i.e. make assumptions
    - e.g. the 2 solvents are completely immiscible
    - e.g. the system is infinitely diluted

- II: Setup system
    - Create mixture -> depends on stage I
    - Solute/drug conformational generation
    - Forcefield selection & comptability

- III: Free energy calculation
    - Compute the solvation (Gibb's) free energy
    - Compute the transfer (Gibb's) free energy: deduce the logP

code: github.com/mobleylab/SolvationToolkit

Workflow: SystemBuild -> ForceFieldAssign ->  FreeEnergyCompute[Optimization, MolecularDynamics]






QCElemental refactor:
=====================
- models:
    - Generic:
        - types
        - basemodels
    - Specific:
        - align
        - basis
        - molecule
        - results
        - procedures
    - Hybrid:
        - common_models

- physical_constants:
    -Generic:
        - context
    -Specific:
        - ureg

- util:
    - Generic:
        - autodocs
        - importing
        - serialization: does it use provenance?
        - itertools
        - misc
        - np_blockwise: maybe
        - np_rand3drot: maybe
        - scipy_hungarian: maybe
        - gph_uno_bipartite: maybe
        - test_gph_uno_bipartite: why is it here?
        - test_scipy_hungarian: why is it here?
    - Specific:
        - internal: defines provenance for QCElemental
        
- molutil:
    - Generic:
        - molecular_formula
        - connectivity
    - Specific:
        - align: maybe?
        - test_molutil: why is it here?

- molparse:
    - Generic:
        - regex
        - pubchem
        - nucleus
    - Specific: 
        - chgmult: QC-sepcific
        - from_arrays: QC-sepcific
        - from_string: QC-sepcific
        - from_schema: QC-sepcific
        - to_schema: QC-sepcific
        - to_string: QC-specific

- info:
    - Generic:
        - cpu_info
    - Specific:
        - dft_info

QCEngine:
=========
    - Generic:
         - programs/model.py -> ProgramHarness
         - util.py -> execute()
         - exceptions.py
         - compute.py: need to replace AtomicInput/AtomicResult

programs.model.ProgramHarness: MMIC vs QCEngine

AtomicResult = compute.compute(AtomicInput)

Generalizing compute.compute and compliance with MMIC design:
- Kill the compute method in QCEngine/programs/*.py ? Diff with execute?
- Use mmic.ProgramHarness in QCEngine


- Logistics: who's involved, and do they agree? How to coordinate?
- What should we refactor? Generic vs general?
- Do we need to have the same ProgramHarness implementation?
